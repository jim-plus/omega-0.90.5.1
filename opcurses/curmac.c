/*** curmac.c*/#include <AppleEvents.h>#include <Files.h>#include <Fonts.h>#include <Menus.h>#include <QDOffscreen.h>#include <Windows.h>#include <signal.h>#include <stdlib.h>#include <time.h>#include <unix.h>#define OPEN_APP	1#define OPEN_DOC	2#define PRINT_DOC	3#define QUIT_APP	4void UserProgramAbout( void );typedef unsigned short chtype;extern int pLINES;extern int pCOLS;int fake_argc = 0;char *fake_argv;char				theKey;long				sleepTime;Boolean				userHasQuit, userHitKey;RgnHandle			cursorRegion;WindowPtr			termWindow;GDHandle			myMainScreen;GWorldPtr			charsetWorld, winWorld;PixMapHandle		charsetHand, winHand;int					charsetRB, winRB, gworldPSize;Ptr					charsetBase, winBase;AEEventHandlerUPP	myAEHandler;void (* mac_putchar)( chtype, short, short );void usleep( long usecs );/* void sleep( long secs ); */void InitializeToolbox( void );int AllocateOffscreenBitmaps( void );int OtherInitialize( void );int SetUpMenus( void );int SetUpTermWindow( void );int SetUpInitialScreen( void );int init_mac_curses( void );void close_mac_curses( void );unsigned char *pathifyFSSpec( FSSpec *file );void FakeCommandLine( FSSpec *saveFile );void HandleAppleMenuCommand( short menuItem );void HandleFileMenuCommand( short menuItem );void HandleMenuCommand( long menuChoice );void HandleMouseDownEvent( EventRecord *thisEvent );void HandleKeyDownEvent( EventRecord *thisEvent );void HandleUpdateEvent( EventRecord *thisEvent );void HandleEvent( EventRecord *thisEvent );pascal OSErr HandleRequiredAppleEvents( const AppleEvent *thisAEvent, const AppleEvent *reply,										long which );short mac_getchar( void );void bigpixel_putchar( chtype c, short x, short y );void smallpixel_putchar( chtype c, short x, short y );void mac_update( short line, short beg, short end );void mac_scroll( void );void mac_beep( void );void mac_clear( void );void usleep( long usecs ){#define ACCEPT_NO_EVENT 0	time_t otime, ntime;	unsigned long sleeptime;	EventRecord myNewEvent;		sleeptime = ( (unsigned long)usecs * CLOCKS_PER_SEC ) / 1000000;	otime = clock();	(void)WaitNextEvent( ACCEPT_NO_EVENT, &myNewEvent, sleeptime, cursorRegion );	while( 1 )	{		ntime = clock();		if (( ntime - otime ) < sleeptime )		{			sleeptime = sleeptime - ( ntime - otime );			otime = ntime;			(void)WaitNextEvent( ACCEPT_NO_EVENT, &myNewEvent, sleeptime, cursorRegion );		}		else			break;	}}/*void sleep( long secs ){	time_t otime, ntime;	unsigned long sleeptime;	EventRecord myNewEvent;		sleeptime = (unsigned long)secs * CLOCKS_PER_SEC;	otime = clock();	(void)WaitNextEvent( ACCEPT_NO_EVENT, &myNewEvent, sleeptime, cursorRegion );	while( 1 )	{		ntime = clock();		if (( ntime - otime ) < sleeptime )		{			sleeptime = sleeptime - ( ntime - otime );			otime = ntime;			(void)WaitNextEvent( ACCEPT_NO_EVENT, &myNewEvent, sleeptime, cursorRegion );		}		else			break;	}}*/void InitializeToolbox( void ){	InitGraf( &qd.thePort );	InitFonts();	InitWindows();	InitMenus();	InitCursor();}int AllocateOffscreenBitmaps( void ){#define CHARSET_RESOURCE_ID   128#define CHARSET_PICT_BITDEPTH 8	CGrafPtr     currentPort;	GDHandle     currentDevice;	Rect         gWorldRect;	OSErr        error;	PicHandle    charsetPict;		GetGWorld( &currentPort, &currentDevice );	myMainScreen = GetMainDevice();		charsetPict = GetPicture( CHARSET_RESOURCE_ID );	if ( NULL == charsetPict )		return -1;			gWorldRect = (*charsetPict)->picFrame;	error = NewGWorld( &charsetWorld, CHARSET_PICT_BITDEPTH, &gWorldRect, (CTabHandle)NULL,					   myMainScreen, noNewDevice );	if ( error != noErr )		return -1;			SetGWorld( charsetWorld, (GDHandle)NULL );	charsetHand = (PixMapHandle)GetGWorldPixMap( charsetWorld );	MoveHHi( (Handle)charsetHand );	LockPixels( charsetHand );	DrawPicture( charsetPict, &gWorldRect );	ReleaseResource( (Handle)charsetPict );		gWorldRect = termWindow->portRect;	error = NewGWorld( &winWorld, CHARSET_PICT_BITDEPTH, &gWorldRect, (CTabHandle)NULL,					   myMainScreen, noNewDevice );	if ( error != noErr )		return -1;			SetGWorld( winWorld, (GDHandle)NULL );	winHand = (PixMapHandle)GetGWorldPixMap( winWorld );	MoveHHi( (Handle)winHand );	LockPixels( winHand );	SetGWorld( currentPort, currentDevice );	charsetRB = (int)( (*charsetHand)->rowBytes & 0x7fff );	winRB = (int)( (*winHand)->rowBytes & 0x7fff );	gworldPSize = (int)( (*charsetHand)->pixelSize );	charsetBase = (Ptr)( (*charsetHand)->baseAddr );	winBase = (Ptr)( (*winHand)->baseAddr );		if ( gworldPSize >= 8 )	{		mac_putchar = bigpixel_putchar;		gworldPSize /= 8;	}	else		mac_putchar = smallpixel_putchar;		return 1;}int OtherInitialize( void ){	int result;		sleepTime = 10;	userHasQuit = false;	userHitKey = false;	cursorRegion = NULL;	myAEHandler = NewAEEventHandlerProc( HandleRequiredAppleEvents );	AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, myAEHandler, OPEN_APP, FALSE);	AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, myAEHandler, OPEN_DOC, FALSE);	AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, myAEHandler, PRINT_DOC, FALSE);	AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, myAEHandler, QUIT_APP, FALSE);	result = SetUpTermWindow();	if ( result < 0 )		return result;	else		return AllocateOffscreenBitmaps();}int SetUpMenus( void ){#define MENUBAR_RESOURCE_ID    128#define APPLE_MENU_RESOURCE_ID 128	Handle		theMenuBar;	MenuHandle	theMenu;		/* Add Menus to Menu List */	theMenuBar = GetNewMBar( MENUBAR_RESOURCE_ID );	if ( theMenuBar == NULL )		return -1;	SetMenuBar( theMenuBar );	DisposeHandle( theMenuBar );		/* Add Apple Menu junk to Apple Menu */	theMenu = GetMenuHandle( APPLE_MENU_RESOURCE_ID );	if ( theMenu == NULL )		return -1;	else		AppendResMenu( theMenu, 'DRVR' );			DrawMenuBar();	return 1;}#define TILE_WIDTH	8#define TILE_HEIGHT	12int SetUpTermWindow( void ){	int wulx, wuly, wlrx, wlry;	int sheight, swidth;	#define WINDOW_RESOURCE_ID 128	termWindow = GetNewCWindow( WINDOW_RESOURCE_ID, (void *)NULL, (WindowPtr)(-1) );	if ( termWindow == NULL )		return -1;		sheight = qd.screenBits.bounds.bottom - qd.screenBits.bounds.top;	swidth = qd.screenBits.bounds.right - qd.screenBits.bounds.left;		if ( swidth <= ( 80 * TILE_WIDTH ) )	{		wulx = 0;		pCOLS = swidth / TILE_WIDTH;		wlrx = pCOLS * TILE_WIDTH;	}	else	{		pCOLS = 80;		wulx = (( swidth - ( 80 * TILE_WIDTH )) / 2 );		if ( wulx > 10 ) wulx = 10;		wlrx = wulx + ( 80 * TILE_WIDTH );	}		if ( sheight <= (( 31 * TILE_HEIGHT ) + ( 2 * GetMBarHeight() )) )	{		wuly = 2 * GetMBarHeight();		pLINES = ( sheight - ( 2 * GetMBarHeight() )) / TILE_HEIGHT;		wlry = wuly + ( pLINES * TILE_HEIGHT );	}	else	{		wuly = 2 * GetMBarHeight() + TILE_HEIGHT;		pLINES = ( sheight - ( 2 * GetMBarHeight() ) - ( 2 * TILE_HEIGHT )) / TILE_HEIGHT;		wlry = wuly + ( pLINES * TILE_HEIGHT );	}		SizeWindow( termWindow, wlrx - wulx, wlry - wuly, FALSE );	MoveWindow( termWindow, wulx, wuly, FALSE );		return 1;}int SetUpInitialScreen( void ){	int result;		if (( result = SetUpMenus() ) < 0 )		return result;	ShowWindow( termWindow );	SetPort( termWindow );	return 1;}int init_mac_curses( void ){	int result;	InitializeToolbox();	FlushEvents( everyEvent, 0 );	if (( result = OtherInitialize() ) < 0 )		return result;		/* constants from unix.h that set up what type & creator will be for saved files */	_fcreator = 'gOme';	_ftype = 'odat';	return SetUpInitialScreen();}void close_mac_curses( void ){	CloseWindow( termWindow );	DisposPtr( (Ptr)termWindow );	DisposeGWorld( charsetWorld );	DisposeGWorld( winWorld );	FlushEvents( everyEvent, 0 );}void HandleAppleMenuCommand( short menuItem ){#define ABOUT_ITEM_ID 1	Str255 appleMenuItem;		if ( menuItem == ABOUT_ITEM_ID )		UserProgramAbout();	else	{		GetMenuItemText( GetMenuHandle( APPLE_MENU_RESOURCE_ID ), menuItem, appleMenuItem );		OpenDeskAcc( appleMenuItem );	}}void HandleFileMenuCommand( short menuItem ){#define QUIT_ITEM_ID 1	if ( menuItem == QUIT_ITEM_ID )		userHasQuit = true;}void HandleMenuCommand( long menuChoice ){#define FILE_MENU_RESOURCE_ID 129	short menuResourceID, menuItem;		menuResourceID = (short)(( menuChoice & 0xffff0000 ) >> 16 );	menuItem = (short)( menuChoice & 0x0000ffff );	switch( menuResourceID )	{		case APPLE_MENU_RESOURCE_ID:			HandleAppleMenuCommand( menuItem );			break;					case FILE_MENU_RESOURCE_ID:			HandleFileMenuCommand( menuItem );			break;					default:			break;			/* Do Nothing */	}	HiliteMenu( 0 );}void HandleMouseDownEvent( EventRecord *thisEvent ){	int mouseDownLocation;	WindowPtr thisWindow;		mouseDownLocation = FindWindow( thisEvent->where, &thisWindow );	switch( mouseDownLocation )	{		case inMenuBar:			HandleMenuCommand( MenuSelect( thisEvent->where ));			break;					case inSysWindow:			SystemClick( thisEvent, thisWindow );			break;					case inDrag:			DragWindow( thisWindow, thisEvent->where, &((*( GetGrayRgn() ))->rgnBBox) );			break;					default:			break;			/* Do Nothing */	}}void HandleKeyDownEvent( EventRecord *thisEvent ){	theKey = (char)( thisEvent->message & charCodeMask );	if ( thisEvent->modifiers & cmdKey )	{		if ( thisEvent->what == keyDown )		{			HandleMenuCommand( MenuKey( theKey ));		}	}	else		userHitKey = true;}void HandleUpdateEvent( EventRecord *thisEvent ){	Rect copyRect;		if ( (Ptr)termWindow == (Ptr)( thisEvent->message ))	{		BeginUpdate( termWindow );		copyRect = (*(termWindow->visRgn))->rgnBBox;			/* Smack that baby up there */		CopyBits( (BitMap *)(*winHand), (BitMap *)(*( ((CWindowPtr)(termWindow))->portPixMap )),				  &copyRect, &copyRect, srcCopy, (RgnHandle)NULL );				EndUpdate( termWindow );	}}/* "C-ified", and modified from IM:Files pp. 2-45, 2-46 *//* Added the ability to return paths longer than 255 characters */unsigned char *pathifyFSSpec( FSSpec *file ){#define PATH_BUF_SIZE	256	int				i, bufMultiple = 1;	CInfoPBRec		myPB;				/* parameter block for PBGetCatInfo */	unsigned char	*dirName;			/* a directory name */	unsigned char	*fullPath;			/* full pathname being constructed */	unsigned char	*tempPtr, *bufPtr, *bufEnd;	fullPath = (unsigned char *)malloc( PATH_BUF_SIZE );	/* initialize full pathname */	if ( fullPath == NULL )		return NULL;	else	{		bufPtr = fullPath;		bufEnd = fullPath + PATH_BUF_SIZE;	}	dirName = (unsigned char *)malloc( PATH_BUF_SIZE );	if ( dirName == NULL )	{		free( fullPath );		return NULL;	}			myPB.dirInfo.ioNamePtr = (StringPtr)( dirName );	myPB.dirInfo.ioVRefNum = file->vRefNum;		/* indicate target volume */	myPB.dirInfo.ioDrParID = file->parID;		/* initialize parent directory ID */	myPB.dirInfo.ioFDirIndex = -1;				/* get info about a directory */	/* Get name of each parent directory, up to root directory. */	do {		myPB.dirInfo.ioDrDirID = myPB.dirInfo.ioDrParID;		PBGetCatInfo( &myPB, FALSE );				/* ignore return value of type OSErr */				/* copy a length-leading string (dirName) to a null-terminated string (fullPath) */		if (( bufPtr + dirName[ 0 ] + 1 ) >= bufEnd )		{			/* we are going to run out of space in fullPath, reallocate with more space */			bufMultiple++;			tempPtr = (unsigned char *)realloc( fullPath, PATH_BUF_SIZE * bufMultiple );			if ( tempPtr == NULL )			{				/* whoops, ran out of memory before path complete - fail */				free( fullPath );				free( dirName );				return NULL;			}			/* restore bufPtr to equivalent location in new buffer */			bufPtr = tempPtr + ( bufPtr - fullPath );			fullPath = tempPtr;			bufEnd = fullPath + ( PATH_BUF_SIZE * bufMultiple );		}		*bufPtr++ = ':';		tempPtr = dirName + 1;		/* skip the length byte */		for ( i = 0; i < dirName[ 0 ]; i++ )			*bufPtr++ = *tempPtr++;				} while( !( myPB.dirInfo.ioDrDirID == fsRtDirID ));	free( dirName );		/* fullPath now has the path, but with the path elements reversed - DOH! */	dirName = fullPath;	fullPath = (unsigned char *)malloc( PATH_BUF_SIZE * bufMultiple );	if ( fullPath == NULL )	{		free( dirName );		return NULL;	}		tempPtr = fullPath;	do {		bufEnd = bufPtr;				/* bufEnd marks the end of the next element to copy */		bufPtr--;						/* bufPtr pts to last char of the next element to copy */		while ( *bufPtr != ':' )		/* move bufPtr back to previous colon */			bufPtr--;		bufPtr++;						/* bufPtr pts to first char of the next element to copy */		while( bufPtr != bufEnd )		/* copy path element to fullPath */			*tempPtr++ = *bufPtr++;		*tempPtr++ = ':';				/* append seperator to fullPath */		bufPtr--;						/* bufPtr pts to last char of element we just copied*/		while( *bufPtr != ':' )			/* move bufPtr back to just before element we just copied */			bufPtr--;	} while( bufPtr != dirName );	free( dirName );		/* copy name of file to complete full path name */	/* roles of bufPtr and tempPtr are swapped here compared to the similar realloc code above */	bufEnd = fullPath + ( PATH_BUF_SIZE * bufMultiple );	if (( tempPtr + file->name[ 0 ] ) >= bufEnd )	{		/* we are going to run out of space in fullPath, reallocate with more space */		bufMultiple++;		bufPtr = (unsigned char *)realloc( fullPath, PATH_BUF_SIZE * bufMultiple );		if ( bufPtr == NULL )		{			/* whoops, ran out of memory before path complete - fail */			free( fullPath );			return NULL;		}		/* restore bufPtr to equivalent location in new buffer */		tempPtr = bufPtr + ( tempPtr - fullPath );		fullPath = bufPtr;	}	bufPtr = (unsigned char *)( &(file->name[ 1 ]) );	for( i = 0; i < file->name[ 0 ]; i++ )		*tempPtr++ = *bufPtr++;	*tempPtr = '\0';					/* terminate fullPath */		return fullPath;					/* return full pathname */}void FakeCommandLine( FSSpec *saveFile ){	FInfo	info;		FSpGetFInfo( saveFile, &info );	if ( info.fdType != 'osav' )		return;	/* wasn't a save file after all... */			fake_argc = 1;	fake_argv = (char *)pathifyFSSpec( saveFile );}/* This is know what file to restore when Omega is opened by double clicking a save file */pascal OSErr HandleRequiredAppleEvents( const AppleEvent *thisAEvent, const AppleEvent *reply,										long which ){#pragma unused( reply )	AEDescList	documents;	AEKeyword	keyword;	DescType	returnedType;	FSSpec		saveFile;	Size		actualSize;	OSErr		err;		switch( which )	{		case OPEN_DOC:			err = AEGetParamDesc( thisAEvent, keyDirectObject, typeAEList, (AEDesc *)(&documents) );			if ( err != noErr ) return err;			/* only open the first one, if more than one selected. This is a game, not a			   word processor, dammit! */			err = AEGetNthPtr( (AEDesc *)(&documents), 1L, typeFSS, &keyword, &returnedType,							   &saveFile, sizeof( FSSpec ), &actualSize );			if ( err != noErr ) return err;			/* pretend that the file name was typed on a command line */			FakeCommandLine( &saveFile );			err = AEDisposeDesc( (AEDesc *)(&documents) );			if ( err != noErr ) return err;			else return noErr;					case OPEN_APP:		case PRINT_DOC:		case QUIT_APP:		default:			/* Don't do anything because we don't give a crap about these events */			return noErr;	}}void HandleEvent( EventRecord *thisEvent ){	switch( thisEvent->what )	{		case mouseDown:			HandleMouseDownEvent( thisEvent );			break;					case keyDown:		case autoKey:			HandleKeyDownEvent( thisEvent );			break;					case updateEvt:			HandleUpdateEvent( thisEvent );			break;					case kHighLevelEvent:			AEProcessAppleEvent( thisEvent );			break;					default:			break;			/* Do Nothing */	}}short mac_getchar( void ){	Boolean gotAnEvent = FALSE;	EventRecord myNewEvent;	time_t otime, ntime;		ntime = otime = clock();	while (( ntime - otime ) < sleepTime )	{		gotAnEvent = WaitNextEvent( everyEvent, &myNewEvent, sleepTime, cursorRegion );		if ( !gotAnEvent )			ntime = clock();		else		{			HandleEvent( &myNewEvent );			if ( userHasQuit )			{				userHasQuit = FALSE;				raise( SIGINT );			}			else if ( userHitKey )			{				userHitKey = FALSE;				return( (int)theKey );			}			else			{				gotAnEvent = FALSE;				ntime = clock();			}		}	}	return -1;}void bigpixel_putchar( chtype c, short x, short y ){#define CHAR_WIDTH  8#define CHAR_HEIGHT 12	unsigned char *ss, *sd;	unsigned long *source, *dest;	int i, j;		/* Figure out where the character is */	ss = (unsigned char *)charsetBase +		 ( charsetRB * ( 1 + (( c / 32 ) * ( CHAR_HEIGHT + 1 ))));	ss += ( gworldPSize * ( 1 + (( c % 32 ) * ( CHAR_WIDTH + 1 ))));	source = (unsigned long *)ss;		/* Figure out where to put the character */	sd = (unsigned char *)winBase + winRB * ( y * CHAR_HEIGHT );	sd += ( gworldPSize * ( x * CHAR_WIDTH ));	dest = (unsigned long *)sd;		/* Smack that baby up there */	for ( j = 0; j < CHAR_HEIGHT; j++ )	{		for ( i = 0; i < ( CHAR_WIDTH * gworldPSize / 4 ); i++ )		{			*dest++ = *source++;		}		source = (unsigned long *)( ss + charsetRB );		ss = (unsigned char *)source;		dest = (unsigned long *)( sd + winRB );		sd = (unsigned char *)dest;	}}void smallpixel_putchar( chtype ch, short x, short y ){	unsigned char c, *ss, *sd, *dest, *source;	int i, j, srcHOffs, dstHOffs;		/* Figure out where the character is */	srcHOffs = 1 + (( ch % 32 ) * ( CHAR_WIDTH + 1 ));	ss = (unsigned char *)charsetBase +		 ( charsetRB * ( 1 + (( ch / 32 ) * ( CHAR_HEIGHT + 1 ))));	ss += ( gworldPSize * srcHOffs / 8 );	source = ss;		/* Figure out where to put the character */	dstHOffs = x * CHAR_WIDTH;	sd = (unsigned char *)winBase + winRB * ( y * CHAR_HEIGHT );	sd += ( gworldPSize * dstHOffs / 8 );	dest = sd;		/* Smack that baby up there */	for ( j = 0; j < CHAR_HEIGHT; j++ )	{		for ( i = 0; i < CHAR_WIDTH; )		{			c = *source++;			switch( gworldPSize )			{				case 1:					switch( srcHOffs % 8 )					{						case 0:							break;													case 1:							c = (( c << 1 ) | (( *source ) >> 7 ));							break;													case 2:							c = (( c << 2 ) | (( *source ) >> 6 ));							break;													case 3:							c = (( c << 3 ) | (( *source ) >> 5 ));							break;													case 4:							c = (( c << 4 ) | (( *source ) >> 4 ));							break;													case 5:							c = (( c << 5 ) | (( *source ) >> 3 ));							break;													case 6:							c = (( c << 6 ) | (( *source ) >> 2 ));							break;													case 7:							c = (( c << 7 ) | (( *source ) >> 1 ));							break;					}					i += 8;					break;									case 2:					switch( srcHOffs % 4 )					{						case 0:							break;													case 1:							c = (( c << 2 ) | (( *source ) >> 6 ));							break;													case 2:							c = (( c << 4 ) | (( *source ) >> 4 ));							break;													case 3:							c = (( c << 6 ) | (( *source ) >> 2 ));							break;					}					i += 4;					break;									case 4:					if ( srcHOffs % 2 )						c = (( c << 4 ) | (( *source ) >> 4 ));					i += 2;					break;			}			*dest++ = c;		}		source = ss + charsetRB;		ss = source;		dest = sd + winRB;		sd = dest;	}}void mac_update( short line, short beg, short end ){	Rect charRect;		/* Figure out from where and to where we copy */	charRect.left = (int)beg * CHAR_WIDTH;	charRect.right = (( (int)end + 1 ) * CHAR_WIDTH );	charRect.top = (int)line * CHAR_HEIGHT;	charRect.bottom = charRect.top + CHAR_HEIGHT;		/* Smack that baby up there */	CopyBits( (BitMap *)(*winHand), (BitMap *)(*( ((CWindowPtr)(termWindow))->portPixMap )),			  &charRect, &charRect, srcCopy, (RgnHandle)NULL );}void mac_scroll( void ){	/* not used */	/* ScrollRect ( &(termWindow->portRect), 0, -CHAR_HEIGHT, (RgnHandle)NULL ); */}void mac_beep( void ){	SysBeep( 30 );}void mac_clear( void ){	GWorldPtr originalPort;	GDHandle originalGD;	PenState savePen;		GetGWorld( &originalPort, &originalGD );	GetPenState( &savePen );	SetGWorld( (GWorldPtr)termWindow, myMainScreen );	PenPat( &(qd.black) );	PaintRect( &(termWindow->portRect) );	SetGWorld( winWorld, (GDHandle)NULL );	PenPat( &(qd.black) );	PaintRect( &(winWorld->portRect) );	SetPenState( &savePen );	SetGWorld( originalPort, originalGD );}